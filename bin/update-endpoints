#!/usr/bin/env node
const { DNSStamp } = require('@leichtgewicht/dnsstamp')
const dnsPacket = require('@leichtgewicht/dns-packet')
const { request, queryDns, loadJSON } = require('../lib.cjs')
const { Endpoint } = require('../common.cjs')
const { writeFile } = require('fs/promises')
const { join } = require('path')
const { inspect } = require('util')
const { URL } = require('url')

;(async () => {
  const endpoints = await loadJSON(new URL('https://download.dnscrypt.info:443/resolvers-list/json/public-resolvers.json'), false, 10000)

  let resolvers = []

  function removeBraces (ipv6) {
    return /^\[(.+)\]$/.exec(ipv6)[1]
  }

  for (const rawEndpoint of endpoints) {
    const { stamp, name, description, country, location, proto } = rawEndpoint
    const parsed = DNSStamp.parse(stamp)
    const {
      path,
      pk,
      port
    } = parsed
    let endpoint
    if (proto === 'DNSCrypt') {
      if (rawEndpoint.ipv6) {
        endpoint = {
          protocol: 'udp6:',
          ipv6: removeBraces(rawEndpoint.addrs[0])
        }
      } else {
        endpoint = {
          protocol: 'udp4:',
          ipv4: rawEndpoint.addrs[0]
        }
      }
      if (pk) {
        endpoint.pk = pk
      }
      if (port !== 53) {
        endpoint.port = port ?? 443
      }
    } else {
      endpoint = {
        protocol: 'https:',
        host: rawEndpoint.addrs[0] || parsed.host
      }
      if (path && path !== '/dns-query') {
        endpoint.path = path
      }
      if (port && port !== 443) {
        endpoint.port = port
      }
      const ip = rawEndpoint.addrs[1]
      if (ip) {
        if (ip.startsWith('[')) {
          endpoint.ipv6 = removeBraces(ip)
        } else {
          endpoint.ipv4 = ip
        }
      }
    }
    resolvers.push({
      name,
      endpoint,
      description,
      country,
      location
    })
  }
  resolvers = resolvers.sort(byName)
  const TIMEOUT = 5000
  const query = {
    flags: dnsPacket.RECURSION_DESIRED,
    type: 'query',
    id: '\x7f\xfe\xff\xfe' /* to test + and / encoding */,
    questions: [{ type: 'A', name: 'google.com' }]
  }
  const packet = dnsPacket.encode(query)

  async function verifyDoH (resolver) {
    const endpoint = new Endpoint(resolver.endpoint)
    const { data, response } = await request(
      endpoint.url,
      endpoint.method,
      packet,
      TIMEOUT
    )
    if (response.headers['access-control-allow-origin'] === '*') {
      resolver.endpoint.cors = true
    }
    return data
  }

  async function verifyDns (resolver) {
    const data = await queryDns(
      resolver.endpoint.protocol,
      resolver.endpoint.ipv4 || resolver.endpoint.ipv6,
      resolver.endpoint.port ?? 53,
      resolver.endpoint.pk,
      query,
      TIMEOUT
    )
    return data
  }

  async function verifyResover (resolver) {
    try {
      const data = await (
        resolver.endpoint.protocol === 'https:'
          ? verifyDoH(resolver)
          : verifyDns(resolver)
      )
      const decoded = dnsPacket.decode(data)
      if (decoded.answers[0].name === 'google.com') {
        resolver.test = true
      } else {
        resolver.test = {
          message: 'Google.com fetch failed'
        }
      }
    } catch (err) {
      let error
      if (typeof err === 'string') {
        error = {
          message: err
        }
      } else {
        error = JSON.stringify(err)
        if (error === '{}') {
          error = {
            message: err.message || String(err)
          }
          if (err.code) {
            error.coded = err.code
          }
        } else {
          error = JSON.parse(error)
        }
      }
      resolver.test = error
    }
  }

  await (await import('p-map')).default(resolvers, verifyResover, { concurrency: 10 })

  function byName (a, b) {
    if (a.name > b.name) return 1
    if (a.name < b.name) return -1
    return 0
  }

  const workingResolvers = resolvers
    .filter(resolver => {
      if (resolver.test === true) {
        console.log(`[USE] ${resolver.name}`)
        return true
      }
      console.log(`[SKIP] ${resolver.name} ─── ${inspect(resolver.test, { sorted: true, depth: 7, colors: true })}`)
      return false
    })
    .map(resolver => {
      const { test, ...rest } = resolver
      return rest
    })

  await writeFile(
    join(__dirname, '..', 'data', 'endpoints.json'),
    JSON.stringify({ resolvers: workingResolvers }, null, 2)
  )
})()
  .catch(err => {
    console.error(err.stack || err)
    process.exit(1)
  })
